function final_trajectory_data= moveL(waypoints,total_time_to_waypoint,ts,...
                                ik,endEffector,ikWeights,ikInitialGuess,...
                                complete_trajectory_data)
% MOVEL Calculates the IK for linear movement of the robot

%{
Calculates the IK for linear movement of the robot
    Inputs:
        waypoints:                  The array of poses of the trajectory.
        total_time_to_waypoint:     Total time between main waypoints.
        ts:                         Time between interval waypoints.
        ik:                         Inverse Kinematic(IK) solver.
        endEffector:                Name of the end effector.
        ikInitialGuess:             Initial Configuration space guess.
        complete_trajectory_data:   Cell array of the trajectory data.
    Outputs:
        final_trajectory_data:      Cell array of the trajectory data(updated).

%}



    %% Setup 
    
    % Get number of waypoints
    numberWaypoints=size(waypoints,3);

    % Allocate memory
    trajectory_data = cell(numberWaypoints - 1,3);
    
    %% Calculate Poses

    for count = 1:numberWaypoints - 1

        % Extract the starting and finishing waypoint times of the segment of the trajectory
        main_waypoints_time_interval = total_time_to_waypoint(count:count + 1);
        % Get the times of the intermediate waypoints in the segment of the trajectory
        intermediate_waypoints_time_interval = main_waypoints_time_interval(1):ts(count):main_waypoints_time_interval(2);

        % Find the transforms from trajectory generation
        
        % Generate transformation between two poses
        [transformation_matrix_array, vel, acc] = transformtraj(waypoints(:, :, count), ...
                                                                waypoints(:, :, count + 1), ...
                                                                main_waypoints_time_interval, ...
                                                                intermediate_waypoints_time_interval);
        % To avoid repeated Waypoints the first one is always eliminated
        if count > 1
            transformation_matrix_array(:, :, 1) = [];
        end

        % Save type of movements and poses
        % Movement Type
        trajectory_data{count,1} = 1; % MoveJ=0 MoveL=1
        % Poses
        trajectory_data{count,2} = transformation_matrix_array;
    end


    %% Robot Inverse Kinematics

    for count = 1:numberWaypoints - 1

        % Get number of Configurations on the configuration space
        size_config_space = size(trajectory_data{count,2}, 3);

        % Allocate memory for the configurations
        config_space_data = zeros(6, size_config_space);

        % Intermediate waypoints movement
        for index = 1:size_config_space

            % Get pose for the IK solver
            target_pose = trajectory_data{count,2}(:, :, index);

            % The IK solver gets the configuration to get the end efector in the desired pose.
            [configuration_space,~] = ik(endEffector, target_pose, ikWeights, ikInitialGuess);
            % The last result turns in the next initial guest
            ikInitialGuess = configuration_space;

            % Save the configuration space in a matrix
            config_space_data(:, index) = configuration_space;
        end

        % Save the configuration space in trajectory data to use it in the Simulation of the robot
        trajectory_data{count,3} = config_space_data;
    end
    
    %% Append Trajectories
    
    % Get the number of waypoints in trajectory data
    numWaypointsTD=size(complete_trajectory_data,1);
    
    % Appends the trajectory data that was input in the function and
    % the one generated by the funtion
    if numWaypointsTD == 0
        final_trajectory_data=trajectory_data;
    elseif numWaypointsTD > 0   
        final_trajectory_data=[complete_trajectory_data;trajectory_data];
    end
end

